/*Copyright 2025 He Jia <mofhejia@163.com>. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#pragma once

#ifndef AXON_CORE_MESSAGE_LIFECYCLE_POLICY_HPP_
#define AXON_CORE_MESSAGE_LIFECYCLE_POLICY_HPP_

#include <proxy/proxy.h>

#include <memory>
#include <type_traits>
#include <variant>

#include "axon/utils/axon_message.hpp"

namespace eux {
namespace axon {

enum class LifecycleStatus : uint8_t {
  Discard = 0,
  Preserve,
  Error,
};

/**
 * @brief Facade for the user to determine the lifecycle status of an
 * AxonRequest.
 *
 * This facade enables custom logic for handling the lifecycle of an
 * AxonRequest. The user-implemented handler receives:
 *   - a shared pointer to the corresponding AxonRequest,
 *   - a uint64_t representing the precomputed hash ID for this AxonRequest
 *     (as generated by the axon worker).
 * It should return a value of LifecycleStatus to indicate whether the request
 * should be preserved or finalized post-processing.
 */
struct LifecycleStatusHandlerFacade
  : pro::facade_builder::add_convention<
      pro::operator_dispatch<"()">,
      LifecycleStatus(
        std::shared_ptr<utils::AxonRequest>,
        utils::AxonMessageID /*axon worker precomputed hash id*/)>::build {};

using LifecycleStatusHandlerView =
  pro::proxy_view<LifecycleStatusHandlerFacade>;

/**
 * @brief A transient message lifecycle policy.
 *
 * With this policy, the lifetime of the request ends immediately after it is
 * processed.
 *
 * @note
 * TransientPolicy is a distinct type indicating that no retention of the
 * message request is required.
 */
struct TransientPolicy {};

/**
 * @brief A retention message lifecycle policy.
 *
 * RetentionPolicy enables users to customize whether to preserve a request
 * object after processing, depending on their own logic.
 *
 * @note
 * RetentionPolicy is a type that is invocable according to the
 * LifecycleStatusHandlerFacadeâ€”that is, any type that fulfills the facade
 * requirements can be used as RetentionPolicy and invoked to determine the
 * lifecycle status.
 */
using RetentionPolicy = LifecycleStatusHandlerView;

/*
Another implementation of RetentionPolicy that is a standalone struct
*/
// struct RetentionPolicy {
//   mutable LifecycleStatusHandlerView handler_view_;
//   RetentionPolicy(LifecycleStatusHandlerView view) : handler_view_(view) {}
//   decltype(auto) operator*() { return *handler_view_; }
// };

using MessageLifecyclePolicy = std::variant<TransientPolicy, RetentionPolicy>;

// Helper: get whether T is among alternatives of variant VariantT
template <typename VariantT, typename T>
struct is_variant_alternative;

template <typename T, typename... Alts>
struct is_variant_alternative<std::variant<Alts...>, T>
  : std::disjunction<std::is_same<std::decay_t<T>, std::decay_t<Alts>>...> {};

template <typename T>
constexpr bool is_message_lifecycle_policy_v =
  std::is_same_v<std::decay_t<T>, MessageLifecyclePolicy>
  || is_variant_alternative<MessageLifecyclePolicy, T>::value;

}  // namespace axon
}  // namespace eux

#endif  // AXON_CORE_MESSAGE_LIFECYCLE_POLICY_HPP_
